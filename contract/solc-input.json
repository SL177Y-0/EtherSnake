{"language":"Solidity","sources":{"SlitherBet.sol":{"content":"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\n\ncontract SlitherBet is Ownable {\n    struct Player {\n        address playerAddress;\n        string nickname;\n        uint256 score;\n        bool hasSubmittedScore;\n    }\n\n    struct Event {\n        uint256 id;\n        uint256 startTime;\n        uint256 duration;\n        uint256 prizePool;\n        address creator;\n        bool isActive;\n        bool isPrizeClaimed;\n        address winner;\n        uint256 highestScore;\n    }\n\n    uint256 public eventCount;\n    uint256 public constant ENTRY_FEE = 0.001 ether;\n    \n    mapping(uint256 => Event) public events;\n    mapping(uint256 => mapping(address => Player)) public eventPlayers;\n    mapping(uint256 => address[]) public eventPlayerAddresses;\n\n    event EventCreated(uint256 eventId, address creator);\n    event PlayerJoined(uint256 eventId, address player, string nickname);\n    event ScoreSubmitted(uint256 eventId, address player, uint256 score);\n    event EventClosed(uint256 eventId, address winner);\n\n    constructor() Ownable(msg.sender) {}\n\n    function createEvent(uint256 _duration) external {\n        eventCount++;\n        events[eventCount] = Event({\n            id: eventCount,\n            startTime: block.timestamp,\n            duration: _duration,\n            prizePool: 0,\n            creator: msg.sender,\n            isActive: true,\n            isPrizeClaimed: false,\n            winner: address(0),\n            highestScore: 0\n        });\n\n        emit EventCreated(eventCount, msg.sender);\n    }\n\n    function joinEvent(uint256 _eventId, string memory _nickname) external payable {\n        require(events[_eventId].isActive, \"Event is not active\");\n        require(block.timestamp < events[_eventId].startTime + events[_eventId].duration, \"Event has ended\");\n        require(msg.value == ENTRY_FEE, \"Entry fee is 0.001 ETH\");\n        require(eventPlayers[_eventId][msg.sender].playerAddress == address(0), \"Player already joined\");\n\n        eventPlayers[_eventId][msg.sender] = Player({\n            playerAddress: msg.sender,\n            nickname: _nickname,\n            score: 0,\n            hasSubmittedScore: false\n        });\n\n        eventPlayerAddresses[_eventId].push(msg.sender);\n        events[_eventId].prizePool += msg.value;\n\n        emit PlayerJoined(_eventId, msg.sender, _nickname);\n    }\n\n    function submitScore(uint256 _eventId, uint256 _score) external {\n        require(events[_eventId].isActive, \"Event is not active\");\n        require(eventPlayers[_eventId][msg.sender].playerAddress != address(0), \"Player not registered\");\n        require(!eventPlayers[_eventId][msg.sender].hasSubmittedScore, \"Score already submitted\");\n\n        eventPlayers[_eventId][msg.sender].score = _score;\n        eventPlayers[_eventId][msg.sender].hasSubmittedScore = true;\n\n        if (_score > events[_eventId].highestScore) {\n            events[_eventId].highestScore = _score;\n            events[_eventId].winner = msg.sender;\n        }\n\n        emit ScoreSubmitted(_eventId, msg.sender, _score);\n    }\n\n    function closeEvent(uint256 _eventId) external {\n        require(events[_eventId].isActive, \"Event is not active\");\n        require(\n            msg.sender == events[_eventId].creator || msg.sender == owner(),\n            \"Only creator or owner can close the event\"\n        );\n        require(\n            block.timestamp >= events[_eventId].startTime + events[_eventId].duration,\n            \"Event duration not finished\"\n        );\n\n        events[_eventId].isActive = false;\n\n        if (events[_eventId].winner != address(0) && !events[_eventId].isPrizeClaimed) {\n            events[_eventId].isPrizeClaimed = true;\n            payable(events[_eventId].winner).transfer(events[_eventId].prizePool);\n        }\n\n        emit EventClosed(_eventId, events[_eventId].winner);\n    }\n\n    function getEventDetails(uint256 _eventId) external view returns (\n        uint256 id,\n        uint256 startTime,\n        uint256 duration,\n        uint256 prizePool,\n        address creator,\n        bool isActive,\n        bool isPrizeClaimed,\n        address winner,\n        uint256 highestScore\n    ) {\n        Event storage e = events[_eventId];\n        return (\n            e.id,\n            e.startTime,\n            e.duration,\n            e.prizePool,\n            e.creator,\n            e.isActive,\n            e.isPrizeClaimed,\n            e.winner,\n            e.highestScore\n        );\n    }\n\n    function getPlayerCount(uint256 _eventId) external view returns (uint256) {\n        return eventPlayerAddresses[_eventId].length;\n    }\n\n    function getPlayerDetails(uint256 _eventId, address _player) external view returns (\n        address playerAddress,\n        string memory nickname,\n        uint256 score,\n        bool hasSubmittedScore\n    ) {\n        Player storage p = eventPlayers[_eventId][_player];\n        return (\n            p.playerAddress,\n            p.nickname,\n            p.score,\n            p.hasSubmittedScore\n        );\n    }\n\n    function getEventPlayers(uint256 _eventId) external view returns (address[] memory) {\n        return eventPlayerAddresses[_eventId];\n    }\n\n    function getTimeRemaining(uint256 _eventId) external view returns (uint256) {\n        Event storage e = events[_eventId];\n        if (!e.isActive) return 0;\n        \n        uint256 endTime = e.startTime + e.duration;\n        if (block.timestamp >= endTime) return 0;\n        \n        return endTime - block.timestamp;\n    }\n}"}},"settings":{"outputSelection":{"*":{"*":["abi","evm.bytecode"]}},"optimizer":{"enabled":true,"runs":200}}}